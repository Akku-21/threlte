<script lang="ts">
	import { Three2, useFrame, useTexture, useThrelte } from '@threlte/core'
	import { Environment, useGltf } from '@threlte/extras'
	import { onMount } from 'svelte'
	import { cubicInOut, cubicOut } from 'svelte/easing'
	import { tweened } from 'svelte/motion'
	import {
		AmbientLight,
		Color,
		CylinderGeometry,
		DirectionalLight,
		Group,
		Mesh,
		MeshStandardMaterial,
		PerspectiveCamera,
		PointLight,
		Scene
	} from 'three'
	import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'
	import { DEG2RAD } from 'three/src/math/MathUtils'
	import { useTimeout } from './game/hooks/useTimeout'
	import { averageScreenColor } from './game/state'
	import { arcadeMachineScene, gameTexture } from './stores'

	const { gltf } = useGltf<{
		nodes: {
			BodyMesh: THREE.Mesh
			LeftCover: THREE.Mesh
			RightCover: THREE.Mesh
			ScreenFrame: THREE.Mesh
			joystick_base: THREE.Mesh
			joystick_stick_application: THREE.Mesh
			joystick_stick: THREE.Mesh
			joystick_cap: THREE.Mesh
			Main_Button_Enclosure: THREE.Mesh
			Main_Button: THREE.Mesh
			Screen: THREE.Mesh
		}
		materials: {
			['machine body main']: THREE.MeshStandardMaterial
			['machine body outer']: THREE.MeshStandardMaterial
			['screen frame']: THREE.MeshStandardMaterial
			['joystick base']: THREE.MeshStandardMaterial
			['joystick stick']: THREE.MeshStandardMaterial
			['joystick cap']: THREE.MeshStandardMaterial
			Screen: THREE.MeshStandardMaterial
		}
	}>('/models/ball-game/archade-machine/arcade_machine_own.glb')

	$: nodes = $gltf?.nodes
	$: materials = $gltf?.materials

	$: if ($gltf) {
		Object.entries($gltf.materials).forEach(([name, material]) => {
			if (!$gltf) return
			const n = name as keyof typeof $gltf.materials
			if (n === 'joystick cap') material.envMapIntensity = 1
			else if (n === 'joystick stick') material.envMapIntensity = 1
			else material.envMapIntensity = 0.2
		})
	}

	let basePointLightIntensity = tweened(0)

	const { scene } = useThrelte()

	scene.background = new Color('#080200')

	onMount(() => {
		setTimeout(() => {
			basePointLightIntensity.set(1, {
				duration: 200
			})
		}, 1000)
	})

	let pointlight: PointLight
	let pointLightIntensity = $basePointLightIntensity
	useFrame(() => {
		const randomSign = Math.random() > 0.5 ? 1 : -1
		const random = -0.01 + Math.random() * 0.02 * randomSign
		pointLightIntensity = $basePointLightIntensity + random
	})

	const scanLinesTexture = useTexture('/models/ball-game/archade-machine/textures/scanlines.png')

	let leftPressed = false
	let rightPressed = false
	let spacePressed = false

	const onKeyUp = (e: KeyboardEvent) => {
		if (e.key === 'ArrowLeft') {
			e.preventDefault()
			leftPressed = false
		} else if (e.key === 'ArrowRight') {
			e.preventDefault()
			rightPressed = false
		} else if (e.key === ' ') {
			spacePressed = false
		}
	}

	const onKeyDown = (e: KeyboardEvent) => {
		if (e.key === 'ArrowLeft') {
			e.preventDefault()
			leftPressed = true
		} else if (e.key === 'ArrowRight') {
			e.preventDefault()
			rightPressed = true
		} else if (e.key === ' ') {
			spacePressed = true
		}
	}

	const rotationStick = tweened(0, {
		duration: 100
	})
	$: if (leftPressed !== rightPressed) {
		if (leftPressed) {
			rotationStick.set(-15 * DEG2RAD)
		} else {
			rotationStick.set(15 * DEG2RAD)
		}
	}
	$: if (leftPressed === rightPressed) {
		rotationStick.set(0)
	}

	const positionZ = tweened(4, {
		duration: 3e3,
		easing: cubicInOut
	})

	let controlsEnabled = false
	const { timeout } = useTimeout()
	timeout(async () => {
		await positionZ.set(1.4)
		controlsEnabled = true
	}, 1e3)

	let controls: OrbitControls
	const { renderer } = useThrelte()
	useFrame(() => {
		if (controls) controls.update()
	})
</script>

<svelte:window on:keydown={onKeyDown} on:keyup={onKeyUp} />

<Three2 type={Scene} bind:ref={$arcadeMachineScene}>
	<Environment path="/hdr/" files="shanghai_riverside_1k.hdr" />

	<Three2
		type={PerspectiveCamera}
		position.z={$positionZ}
		rotation.x={DEG2RAD * -11}
		position.y={1.5}
		fov={30}
		makeDefault
		let:ref={camera}
	>
		<Three2
			enabled={controlsEnabled}
			bind:ref={controls}
			type={OrbitControls}
			args={[camera, renderer?.domElement]}
			target.y={1.24}
		/>
	</Three2>

	{#if nodes && materials}
		<!-- Generated by gltfjsx -->
		<Three2 type={Group} rotation.y={DEG2RAD * 180}>
			<Three2
				type={Mesh}
				geometry={nodes.BodyMesh.geometry}
				material={materials['machine body main']}
				position={[0.2755, 0, 0]}
				castShadow
				receiveShadow
			/>
			<Three2
				type={Mesh}
				geometry={nodes.LeftCover.geometry}
				material={materials['machine body outer']}
				position={[0.3, 1.2099, -0.1307]}
				castShadow
				receiveShadow
			/>
			<Three2
				type={Mesh}
				geometry={nodes.RightCover.geometry}
				material={materials['machine body outer']}
				position={[-0.3, 1.2099, -0.1307]}
			/>
			<Three2
				type={Mesh}
				geometry={nodes.ScreenFrame.geometry}
				material={materials['screen frame']}
				position={[0.2755, 0.0633, 0.0346]}
				castShadow
				receiveShadow
			/>
			<Three2
				type={Mesh}
				geometry={nodes.joystick_base.geometry}
				material={materials['joystick base']}
				position={[0.1336, 0.9611, -0.1976]}
				rotation={[-0.1939, 0, 0]}
				scale={[-8.3542, -0.0936, -8.3542]}
				castShadow
				receiveShadow
			/>
			<Three2
				type={Mesh}
				geometry={nodes.joystick_stick_application.geometry}
				material={materials['joystick base']}
				position={[0.1336, 0.9668, -0.1987]}
				rotation={[-0.1939, 0, $rotationStick]}
				scale={[-1.5153, -0.1359, -1.5153]}
				castShadow
				receiveShadow
			>
				<Three2
					type={Mesh}
					geometry={nodes.joystick_stick.geometry}
					material={materials['joystick stick']}
					position={[0, 0.1066, -0.0001]}
					scale={[-0.6599, -7.3598, -0.6599]}
					castShadow
					receiveShadow
				>
					<Three2
						type={Mesh}
						geometry={nodes.joystick_cap.geometry}
						material={materials['joystick cap']}
						position={[-0.0001, 0.1126, -0.0005]}
						castShadow
						receiveShadow
					/>
				</Three2>
			</Three2>

			<Three2
				type={Mesh}
				geometry={nodes.Main_Button_Enclosure.geometry}
				material={materials['joystick base']}
				position={[-0.1143, 0.9795, -0.0933]}
				rotation={[-0.1801, 0, 0]}
				scale={0.9409}
			>
				<Three2
					type={Mesh}
					geometry={nodes.Main_Button.geometry}
					material={materials['joystick cap']}
					position={[0.0001, 0.007 + (spacePressed ? -0.003 : 0), -0.0003]}
					rotation={[0.192, 0, 0]}
					scale={0.724}
				/>
			</Three2>

			<!-- The screen itself gets a special treatment -->
			<Three2
				type={Mesh}
				geometry={nodes.Screen.geometry}
				position={[0, 1.3774, 0.1447]}
				scale={1.0055}
			>
				<Three2
					type={MeshStandardMaterial}
					metalness={0.9}
					roughness={0.2}
					map={scanLinesTexture}
					metalnessMap={scanLinesTexture}
					color={'#141414'}
					emissiveMap={$gameTexture}
					emissive={pointLightIntensity}
					envMapIntensity={0.2}
				/>
			</Three2>
		</Three2>
	{/if}

	<!-- This PointLight replicates the light emitted by the screen -->
	{#if nodes}
		<Three2
			type={PointLight}
			position.y={1.376583185239323}
			position.z={-0.12185962320246482}
			intensity={200 * pointLightIntensity}
			distance={1.2}
			decay={2}
			color={$averageScreenColor}
			let:ref
			bind:ref={pointlight}
			castShadow
			shadow.camera.near={0.1}
			shadow.camera.far={3}
			shadow.mapSize.height={512}
			shadow.mapSize.width={512}
		/>
	{/if}

	<Three2 type={AmbientLight} intensity={3} color={$averageScreenColor} />
	<Three2 type={AmbientLight} intensity={0.05} color={'white'} />

	<!-- Red light -->
	<Three2
		type={DirectionalLight}
		intensity={0.3}
		color="#F67F55"
		position.x={-1}
		position.y={3}
		position.z={3}
	/>

	<!-- Blue light -->
	<Three2
		type={DirectionalLight}
		intensity={0.4}
		position.y={3}
		color="#2722F3"
		position.x={1}
		position.z={3}
	/>
</Three2>

<!-- Floor -->

<Three2 type={Mesh}>
	<Three2 type={CylinderGeometry} args={[1, 1, 0.04, 64]} />
	<Three2 type={MeshStandardMaterial} color={'#0f0f0f'} />
</Three2>
