<script lang="ts">
	import { InteractiveObject, Three2, useFrame, useTexture, useThrelte } from '@threlte/core'
	import { Environment, Text, useCursor } from '@threlte/extras'
	import { onMount } from 'svelte'
	import { cubicInOut } from 'svelte/easing'
	import { spring, tweened } from 'svelte/motion'
	import {
		AmbientLight,
		Color,
		CylinderGeometry,
		DirectionalLight,
		Group,
		Mesh,
		MeshStandardMaterial,
		Object3D,
		PerspectiveCamera,
		PointLight,
		Scene
	} from 'three'
	import { DEG2RAD } from 'three/src/math/MathUtils'
	import { arcadeMachineAsset } from './assets'
	import { averageScreenColor, gameState } from './game/state'
	import { arcadeMachineScene, gameTexture } from './stores'

	const { gltf } = arcadeMachineAsset

	$: nodes = $gltf?.nodes
	$: materials = $gltf?.materials

	$: if ($gltf) {
		Object.entries($gltf.materials).forEach(([name, material]) => {
			if (!$gltf) return
			const n = name as keyof typeof $gltf.materials
			if (n === 'joystick cap') material.envMapIntensity = 1
			else if (n === 'joystick stick') material.envMapIntensity = 1
			else material.envMapIntensity = 0.2
		})
	}

	let basePointLightIntensity = tweened(0)

	onMount(() => {
		setTimeout(() => {
			basePointLightIntensity.set(1, {
				duration: 200
			})
		}, 1000)
	})

	const { state } = gameState

	let pointlight: PointLight
	let pointLightIntensity = $basePointLightIntensity
	useFrame(() => {
		if ($state === 'off') {
			pointLightIntensity = 1
		} else {
			const randomSign = Math.random() > 0.5 ? 1 : -1
			const random = -0.01 + Math.random() * 0.02 * randomSign
			pointLightIntensity = $basePointLightIntensity + random
		}
	})

	const scanLinesTexture = useTexture('/models/ball-game/archade-machine/textures/scanlines.png')

	let leftPressed = false
	let rightPressed = false
	let spacePressed = false

	const tipsOpacity = tweened(1, {
		duration: 200
	})

	const onKeyUp = (e: KeyboardEvent) => {
		if (e.key === 'ArrowLeft') {
			e.preventDefault()
			leftPressed = false
		} else if (e.key === 'ArrowRight') {
			e.preventDefault()
			rightPressed = false
		} else if (e.key === ' ') {
			spacePressed = false
		}
	}

	const onKeyDown = (e: KeyboardEvent) => {
		if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight' && e.key !== ' ') return
		tipsOpacity.set(0)
		if (e.key === 'ArrowLeft') {
			e.preventDefault()
			leftPressed = true
		} else if (e.key === 'ArrowRight') {
			e.preventDefault()
			rightPressed = true
		} else if (e.key === ' ') {
			spacePressed = true
		}
	}

	const rotationStick = tweened(0, {
		duration: 100
	})
	$: if (leftPressed !== rightPressed) {
		if (leftPressed) {
			rotationStick.set(-15 * DEG2RAD)
		} else {
			rotationStick.set(15 * DEG2RAD)
		}
	}
	$: if (leftPressed === rightPressed) {
		rotationStick.set(0)
	}

	const cameraTweenZ = tweened(4, {
		duration: 3e3,
		easing: cubicInOut
	})

	$: cameraTweenZ.set($state === 'off' ? 4 : 1.4)

	const { pointer } = useThrelte()

	let screenFocused = false

	const screenPos = {
		x: 0,
		y: 1.3774,
		z: 0.1447
	}

	const cameraTargetPos = spring(
		{
			x: $pointer.x * 0.1,
			y: 1.25,
			z: 0
		},
		{
			precision: 0.000001
		}
	)
	$: cameraTargetPos.set(
		screenFocused
			? {
					...screenPos,
					z: -screenPos.z
			  }
			: {
					x: $pointer.x * 0.1,
					y: 1.25,
					z: 0
			  }
	)

	const cameraPos = spring(
		{
			x: $pointer.x * ($state === 'off' ? 2 : 0.1),
			y: 1.5,
			z: $cameraTweenZ
		},
		{
			stiffness: 0.05,
			damping: 0.9,
			precision: 0.00001
		}
	)
	$: cameraPos.set(
		screenFocused
			? {
					x: screenPos.x,
					y: screenPos.y + 0.15,
					z: screenPos.z + 0.5
			  }
			: {
					x: $pointer.x * ($state === 'off' ? 2 : 0.1),
					y: 1.5,
					z: $cameraTweenZ
			  }
	)

	let cameraTarget: Object3D | undefined = undefined
	let camera: PerspectiveCamera | undefined = undefined
	useFrame(() => {
		if (!camera || !cameraTarget) return
		camera.lookAt(cameraTarget.position)
	})

	const { onPointerEnter, onPointerLeave } = useCursor('pointer')

	const onScreenClick = () => {
		screenFocused = !screenFocused
	}

	const backgroundColor = tweened(new Color('#570b0b'), {
		duration: 2.5e3
	})
	$: if ($state === 'off') {
		backgroundColor.set(new Color('#570b0b'))
	} else {
		backgroundColor.set(new Color('#020203'))
	}

	const { scene } = useThrelte()
	$: scene.background = new Color($backgroundColor)
</script>

<svelte:window on:keydown={onKeyDown} on:keyup={onKeyUp} />

<Three2 type={Scene} bind:ref={$arcadeMachineScene}>
	<Environment path="/hdr/" files="shanghai_riverside_1k.hdr" />

	<Three2
		position.x={$cameraTargetPos.x}
		position.y={$cameraTargetPos.y}
		position.z={$cameraTargetPos.z}
		bind:ref={cameraTarget}
		type={Object3D}
		let:ref
	/>

	<Three2
		type={PerspectiveCamera}
		position.x={$cameraPos.x}
		position.y={$cameraPos.y}
		position.z={$cameraPos.z}
		fov={30}
		makeDefault
		bind:ref={camera}
		let:ref={camera}
	/>

	{#if nodes && materials}
		<!-- Generated by gltfjsx -->
		<Three2 type={Group} rotation.y={DEG2RAD * 180}>
			<Three2
				type={Mesh}
				geometry={nodes.BodyMesh.geometry}
				material={materials['machine body main']}
				position={[0.2755, 0, 0]}
				castShadow
				receiveShadow
			/>
			<Three2
				type={Mesh}
				geometry={nodes.LeftCover.geometry}
				material={materials['machine body outer']}
				position={[0.3, 1.2099, -0.1307]}
				castShadow
				receiveShadow
			/>
			<Three2
				type={Mesh}
				geometry={nodes.RightCover.geometry}
				material={materials['machine body outer']}
				position={[-0.3, 1.2099, -0.1307]}
			/>
			<Three2
				type={Mesh}
				geometry={nodes.ScreenFrame.geometry}
				material={materials['screen frame']}
				position={[0.2755, 0.0633, 0.0346]}
				castShadow
				receiveShadow
			/>

			<!-- Joystick -->

			<Three2
				type={Mesh}
				geometry={nodes.joystick_base.geometry}
				material={materials['joystick base']}
				position={[0.1336, 0.9611, -0.1976]}
				rotation={[-0.1939, 0, 0]}
			>
				{#if $tipsOpacity > 0}
					<Three2 type={Group} position.y={0.16} rotation.y={180 * DEG2RAD} rotation.x={0.1939}>
						<Text
							fillOpacity={$tipsOpacity}
							fontSize={0.02}
							text="Arrow Keys"
							anchorX="50%"
							anchorY="50%"
						/>
					</Three2>
				{/if}
			</Three2>
			<Three2
				type={Mesh}
				geometry={nodes.joystick_stick_application.geometry}
				material={materials['joystick base']}
				position={[0.1336, 0.9668, -0.1987]}
				rotation={[-0.1939, 0, $rotationStick]}
			>
				<Three2
					type={Mesh}
					geometry={nodes.joystick_stick.geometry}
					material={materials['joystick stick']}
					position={[0, -0.0145, 0.0001]}
				>
					<Three2
						type={Mesh}
						geometry={nodes.joystick_cap.geometry}
						material={materials['joystick cap']}
						position={[-0.0001, 0.1126, -0.0005]}
						material.envMapIntensity={0.5}
					/>
				</Three2>
			</Three2>

			<Three2
				type={Mesh}
				geometry={nodes.Main_Button_Enclosure.geometry}
				material={materials['joystick base']}
				position={[-0.1143, 0.9795, -0.0933]}
				rotation={[-0.1801, 0, 0]}
				scale={0.9409}
			>
				{#if $tipsOpacity > 0}
					<Three2 type={Group} position.y={0.05} rotation.y={180 * DEG2RAD} rotation.x={0.1801}>
						<Text
							fillOpacity={$tipsOpacity}
							fontSize={0.02}
							text="Space"
							anchorX="50%"
							anchorY="50%"
						/>
					</Three2>
				{/if}
				<Three2
					type={Mesh}
					geometry={nodes.Main_Button.geometry}
					material={materials['joystick cap']}
					position={[0.0001, 0.007 + (spacePressed ? -0.003 : 0), -0.0003]}
					rotation={[0.192, 0, 0]}
					scale={0.724}
				/>
			</Three2>

			<!-- The screen itself gets a special treatment -->
			<Three2
				type={Mesh}
				geometry={nodes.Screen.geometry}
				position={[0, 1.3774, 0.1447]}
				scale={1.0055}
				let:ref={screen}
			>
				<InteractiveObject
					object={screen}
					on:pointerenter={onPointerEnter}
					on:pointerleave={onPointerLeave}
					interactive
					on:click={onScreenClick}
				/>
				<Three2
					type={MeshStandardMaterial}
					metalness={0.9}
					roughness={0.2}
					map={scanLinesTexture}
					metalnessMap={scanLinesTexture}
					color={'#141414'}
					emissiveMap={$gameTexture}
					emissive={pointLightIntensity}
					emissiveIntensity={1}
					envMapIntensity={0.2}
				/>
			</Three2>
		</Three2>
	{/if}

	<!-- This PointLight replicates the light emitted by the screen -->
	{#if nodes}
		<Three2
			type={PointLight}
			args={['black']}
			position.y={1.376583185239323}
			position.z={-0.12185962320246482}
			intensity={200 * pointLightIntensity}
			distance={1.2}
			decay={2}
			color={$averageScreenColor}
			bind:ref={pointlight}
			castShadow
			shadow.camera.near={0.1}
			shadow.camera.far={3}
			shadow.mapSize.height={512}
			shadow.mapSize.width={512}
		/>
	{/if}

	<Three2 type={AmbientLight} intensity={3} color={$averageScreenColor} />
	<Three2 type={AmbientLight} intensity={0.05} color={'white'} />

	<!-- Red light -->
	<Three2
		type={DirectionalLight}
		intensity={0.3}
		color="#F67F55"
		position.x={-1}
		position.y={3}
		position.z={3}
	/>

	<!-- Blue light -->
	<Three2
		type={DirectionalLight}
		intensity={0.4}
		position.y={3}
		color="#2722F3"
		position.x={1}
		position.z={3}
	/>
</Three2>

<!-- Floor -->

<Three2 type={Mesh}>
	<Three2 type={CylinderGeometry} args={[1, 1, 0.04, 64]} />
	<Three2 type={MeshStandardMaterial} color={'#0f0f0f'} />
</Three2>
