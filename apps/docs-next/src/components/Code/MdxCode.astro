---
import Code from '$components/Code/Code.astro'
import { parse, type HTMLElement } from 'node-html-parser'
import type { HtmlRendererOptions } from 'shiki'

interface Props {
  className?: string
  metastring?: string
}

const isHTMLElement = (node: any): node is HTMLElement => {
  return 'attributes' in node
}

const content = await Astro.slots.render('default')
const parsed = parse(content)
const codeEl = parsed.firstChild

if (!codeEl || !isHTMLElement(codeEl)) {
  throw new Error('No code element found')
}

const props: Record<string, any> = {}

const codeComponentProps = ['title', 'class'] as const

const propFormatters: Partial<
  Record<(typeof codeComponentProps)[number] & string, (value: string) => string>
> = {
  // "title of file" => title of file
  title: (value) => value.replace(/['"]+/g, ''),
  class: (value) => value.replace(/['"]+/g, '')
}

const language = (codeEl.attributes as any).class?.split(' ')[0].replace('language-', '')
const metastring = (codeEl.attributes as any).metastring as string | undefined

const lineOptions: HtmlRendererOptions['lineOptions'] = []

if (metastring) {
  const elements = metastring.split(' ')
  for (const element of elements) {
    console.log(element)
    const keyElementPair = element.split('=')

    if (keyElementPair.length === 2) {
      // it's likely an assignment

      let [key, value] = keyElementPair

      if (!key || !value) {
        // sanity check
        continue
      }

      // run formatter if it exists
      const formatter = propFormatters[key as keyof typeof propFormatters]
      if (formatter) {
        value = formatter(value)
      }

      if (codeComponentProps.includes(key as any)) {
        props[key] = value
      }
    } else {
      // it can be a line highlight
      // regex: {[\d-,]+}
      const lineHighlightRegex = /{[\d-,]+}/
      const lineHighlightMatch = element.match(lineHighlightRegex)
      const lineHighlightString = lineHighlightMatch?.[0]
      if (lineHighlightString) {
        // separate by comma
        const groups = lineHighlightString.split(',')
        // trim whitespace and { and }
        const trimmedGroups = groups.map((group) => group.trim().replace(/[{}]/g, ''))

        for (const group of trimmedGroups) {
          // separate by dash
          const range = group.split('-')
          if (range.length === 2) {
            // it's a range
            const [start, end] = range.map((num) => parseInt(num, 10))
            if (!start || !end) {
              // sanity check
              continue
            }
            for (let i = start; i <= end; i++) {
              lineOptions.push({ line: i, classes: ['highlighted'] })
            }
          } else {
            // it's a single line
            const line = parseInt(group, 10)
            lineOptions.push({ line, classes: ['highlighted'] })
          }
        }
      }
    }
  }
}

console.log(lineOptions)
---

<Code
  code={codeEl.text}
  lang={language}
  lineOptions={lineOptions}
  {...props}
/>
